"""Implementation of simulated annealing algorithm for travelling salesman"""
import os
from copy import copy
from math import exp
from random import random, randrange, shuffle

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from geopy.distance import geodesic
from matplotlib.animation import FuncAnimation
from tqdm import tqdm


def population_to_int(population):
    """Converts population to integer value ignoring malformed values"""
    try:
        return int(population)
    except ValueError:
        return np.nan


def extract_city_coordinates(city_data, city_name):
    """Extracts coordinates of the chosen city as a tuple of floats"""
    coords_df = city_data[city_data.city == city_name][['geo_lat', 'geo_lon']]
    return coords_df.iat[0, 0], coords_df.iat[0, 1]


def calculate_total_distance(city_names, distances):
    """Calculates the total distance travelling through the cities

    The order of elements in ``city_names`` matters.

    Returns:
        Scalar - the total distance of travelling in kilometers.

    """
    total_distance = 0
    for i, city_a in enumerate(city_names):
        next_i = (i + 1) % len(city_names)
        city_b = city_names[next_i]
        total_distance += distances[f'{city_a}-{city_b}']

    return total_distance


def new_route_proposal(city_names):
    """Generates a new route proposal for the travel

    The new route is generated by exchanging the positions of two cities in the
    path.

    """
    index_a = randrange(len(city_names))
    index_b = randrange(len(city_names))
    names_copy = copy(city_names)
    names_copy[index_a], names_copy[index_b] = (names_copy[index_b],
                                                names_copy[index_a])
    return names_copy


def simulated_annealing(city_names,
                        distances,
                        max_iters: int,
                        initial_T: float = 2.0,
                        decay_constant: float = 1.0):
    """Use SA algorithm to find the shortest path around all the cities

    Args:
        city_names: List of cities to travel around.
        distances: Object containing the distance between any pair of cities
            present in ``city_names``. The object can be anything as long as
            ``calculate_total_distance`` helper knows how to handle it.
        max_iters: Maximum iterations for the algorithm.
        initial_T: Starting temperature factor.
        decay_constant: lambda value in exponential decay formula.

    """
    current_route = copy(city_names)
    shuffle(current_route)
    best_result = calculate_total_distance(current_route, distances)
    current_distance = best_result
    best_route = copy(current_route)

    sample_routes = list()

    T = initial_T
    for i in tqdm(range(max_iters)):
        route_proposal = new_route_proposal(current_route)
        proposal_distance = calculate_total_distance(route_proposal, distances)
        if proposal_distance < current_distance:
            current_route = route_proposal
            current_distance = proposal_distance
            if current_distance < best_result:
                best_result = current_distance
                best_route = current_route
                sample_routes.append(best_route)
        else:
            try:
                acceptance_value = exp(
                    (current_distance - proposal_distance) / T)
            except ZeroDivisionError:
                break

            if random() < acceptance_value:
                current_route = route_proposal
                current_distance = proposal_distance

        T = initial_T * exp(-decay_constant * (i + 1))

    return best_route, sample_routes


def draw_route(route, line, city_data):
    """Draw a line representing a route around the cities

    Args:
        route: Ordered list of cities in a route.
        line: Object to use for line drawing.
        city_data: City information containing coordinates.

    Returns:
        Line object used for drawing.

    """
    xdata, ydata = list(), list()
    for city_name in route:
        city_y, city_x = extract_city_coordinates(city_data, city_name)
        xdata.append(city_x)
        ydata.append(city_y)

    xdata.append(xdata[0])
    ydata.append(ydata[0])

    line.set_data(xdata, ydata)
    return line,


def animate_annealing(sample_routes, city_data):
    """Create an animation object of annealing visualization

    Args:
        sample_routes: List of routes generated during annealing.
        city_data: City information containing coordinates.

    Returns:
        Animation object.

    """
    figure = plt.figure()
    axes = plt.axes(xlim=(20, 145), ylim=(40, 65))
    line, = axes.plot(list(), list(), lw=2)
    animation = FuncAnimation(figure,
                              draw_route,
                              frames=sample_routes,
                              fargs=(line, city_data),
                              blit=True)
    return animation


def main():
    """Driver method of the script"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    city_data: pd.DataFrame = pd.read_csv(
        os.path.join(script_dir, 'cities.csv'),
        converters={'population': population_to_int})
    # Take 30 most populated cities
    city_data.sort_values('population', ascending=False, inplace=True)
    city_data = city_data[:30]

    city_names = list(city_data['city'])
    distances = dict()
    for name_a in city_names:
        for name_b in city_names:
            coords_a = extract_city_coordinates(city_data, name_a)
            coords_b = extract_city_coordinates(city_data, name_b)
            distances[f'{name_a}-{name_b}'] = geodesic(coords_a, coords_b).km

    best_route, sample_routes = simulated_annealing(city_names,
                                                    distances,
                                                    10000000,
                                                    initial_T=100,
                                                    decay_constant=1e-5)
    best_distance = calculate_total_distance(best_route, distances)

    best_route.append(best_route[0])
    print('Best route found:')
    print(' -> '.join(best_route))
    print(f'Total distance: {best_distance:.3f} km')

    animation = animate_annealing(sample_routes, city_data)
    animation.save(os.path.join(script_dir, 'animation.mp4'))


if __name__ == '__main__':
    main()
